<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bith01ic blog</title>
    <description>bitholic blog</description>
    <link>https://bitholic.org/</link>
    <atom:link href="https://bitholic.org/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 29 Mar 2018 23:36:52 +0800</pubDate>
    <lastBuildDate>Thu, 29 Mar 2018 23:36:52 +0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>JVM GC Algorithms</title>
        <description>&lt;h2 id=&quot;关于gc&quot;&gt;关于GC&lt;/h2&gt;

&lt;p&gt;GC(Grabage Collection)是JVM中最核心的技术之一，随着多年的发展，GC算法出现了很多变种，适用于不同的环境，选择合适的算法对于新手来说往往是一个难点。虽然这些算法的实现有所不同，但GC的核心思想基本一致：&lt;strong&gt;找到所有“活”（使用）的对象，清除所有“死”（未使用）的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;标记活的对象&quot;&gt;标记“活”的对象&lt;/h2&gt;

&lt;p&gt;所有的GC算法都要首先能找到“活”的对象，早期的GC使用引用计数的方式，这种方式有很多缺陷，比如不能清除循环引用。而现在的GC普遍采用可达性分析算法，首先来看一幅图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/GC_ROOTS.png&quot; alt=&quot;GC_ROOTS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出，我们可以从GC ROOTS开始找到所有有用的对象，那么首先看下什么样的对象可以作为有效的GC ROOTS：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VM栈中引用的对象，或者说当前所有被调用方法的引用类型的参数、局部变量、临时值。&lt;/li&gt;
  &lt;li&gt;JNI(native栈)中引用的对象&lt;/li&gt;
  &lt;li&gt;方法区中常量或静态变量引用的对象&lt;/li&gt;
  &lt;li&gt;系统类（由bootstrap/system class loader加载的对象，比如 rt.jar 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.*&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;其它&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记时就可以从这些GC ROOTS出发找到当前所有有用的对象，并将其标记为“活”对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是，GC进程在执行标记时，应用进程是需要被停止的，对于应用层来说，这个阶段被称为“Stop the World(STW)”。并且暂停的时间取决于“活”对象的数目，而不在于堆的大小。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;清除无用的对象&quot;&gt;清除无用的对象&lt;/h2&gt;

&lt;p&gt;不同的GC算法主要的区别就在于如何清除无用对象，并且大致可以分为以下几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Sweep（清除）：这是简单的方式，它直接将标记为无用的对象释放。一般内部维持一个free-list，记录所有空闲的空间，但这种方式的问题在于会产生很多内存碎片，可能出现内存碎片加起来很大确出现OOM。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_Sweep.png&quot; alt=&quot;Mark_Sweep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Compact（压缩、整理）：这种方式弥补了Sweep的缺点，在执行为清除后，将所有的对象都拷贝到一块，避免了内存碎片的产生。这种方法的缺点是会增加STW的时间，因为拷贝对象和更改引用地址需要额外的时间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_Sweep_Compact.png&quot; alt=&quot;Mark_Sweep_Compact&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copy（复制）：这种方式和Compact很像，都是重新分配活对象的空间，但是Copy一般使用两个空间，一般称为存活区，每次GC时都将存活的对象放到其中一个存活区里，这种方式的好处是拷贝可以和标记同时进行，降低STW的时间，缺点是需要两个存活区，为了能够存下活的对象，他们都得足够大，这就浪费了一些内存空间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_and_Copy.png&quot; alt=&quot;Mark_and_Copy&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Inremental（增量）：增量不是一种新的算法，它的基本思想是如果GC一次性进行所有的垃圾清理会造成很长的STW，那么就将GC过程分为多个阶段，每次只收集部分区域。这种方式的缺陷是带来了线程切换的额外消耗，造成系统吞吐量下降。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分代：分代也不是一种新的算法，它的基本思想是将内存分代，不同的代使用前面提到过的不同的算法。一般将内存分为新生代（Young Generation）和老年代（Old Generation），新生代一般存储刚产生的、存活周期短的对象，在新生代存活超过一定周期后对象会被放入老年代。在年轻代一般选择效率较高的复制算法，老年代一般选择标记-压缩算法。如：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/GC_generations.png&quot; alt=&quot;GC_generations&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;详解分代&quot;&gt;详解分代&lt;/h2&gt;

&lt;p&gt;分代是一种重要的思想，&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
        <link>https://bitholic.org/2018/03/29/JVM_GC_Algorithms/</link>
        <guid isPermaLink="true">https://bitholic.org/2018/03/29/JVM_GC_Algorithms/</guid>
        
        <category>Java</category>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>How Java Threads Works</title>
        <description>&lt;h1 id=&quot;how-java-threads-works&quot;&gt;How Java Threads Works&lt;/h1&gt;

&lt;h2 id=&quot;1-线程简介&quot;&gt;1. 线程简介&lt;/h2&gt;

&lt;h3 id=&quot;11-并发concurrency的历史&quot;&gt;1.1 并发（Concurrency）的历史：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在上古时期，那是的计算机还没有操作系统，程序只能从头到尾的运行并且能够获取计算机的所有资源。&lt;/li&gt;
  &lt;li&gt;在操作系统出现以后，允许了多个程序作为不同的&lt;strong&gt;进程（processes）&lt;/strong&gt;同时运行，操作系统给进程分配资源，线程间可以通过sockets, signal, shared memory, files等进行通信。&lt;/li&gt;
  &lt;li&gt;随着计算机程序复杂度的提高，同一个进程也需要在同时运行不同的任务，这就激发了线程（threads）的出现。线程允许在同一个进程内并发执行多个程序流，并且它们共享进程的资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程也被称为轻量级进程，在现代操作系统上，线程（而不是进程）往往作为CPU调度的基本单元。在现代的多核CPU上，线程能够做到真正意义上的同时运行（并行）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;并发（Concurencey）：多个任务以时间片的方式在一段时间内交替运行（上下文切换），在指定时刻，还是只有一个任务在执行。&lt;/p&gt;

  &lt;p&gt;并行（Parallelism）：多个任务真正的同时运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-线程带来的风险&quot;&gt;1.2 线程带来的风险&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;安全问题：&lt;/li&gt;
  &lt;li&gt;活性问题：&lt;/li&gt;
  &lt;li&gt;性能问题：&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-java中的线程&quot;&gt;2. Java中的线程&lt;/h2&gt;

&lt;p&gt;Java中线程是以类&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;来表示的，在Java中创建线程的唯一方式就是创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;的实例。可通过调用线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;start()&lt;/code&gt;方法来启动这个线程。&lt;/p&gt;

&lt;p&gt;没有正确同步的线程的行为往往会让人感到困扰。Java通过&lt;em&gt;Java programming language memory model&lt;/em&gt;(有时会简称为the memory model)的语义描述多线程的行为，这个语义并没有规定多线程程序应该怎样运行，而是描述了多线程程序运行时可被允许的行为表现。&lt;/p&gt;

&lt;h3 id=&quot;21-同步synchronization&quot;&gt;2.1 同步（Synchronization）&lt;/h3&gt;

&lt;p&gt;Java 语言提供了多种线程间通信的机制，最常见也最基础的就是通过 monitors 实现的同步机制。Java 中的每个对象都会与一个 monitor 相关联，线程可以 &lt;em&gt;lock&lt;/em&gt; 和 &lt;em&gt;unlock&lt;/em&gt; 这个 monitor。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程 lock 了一个对象的 monitor 有时也称为线程拥有了 monitor 的锁或线程拥有了对象的锁，同样，线程 unlock 一个对象的 monitor 也称为线程释放了 monitor 的锁或线程释放了对象的锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在同一个时刻只能有一个线程能够拥有对 monitor 的锁，其它尝试 lock 这个 monitor 的线程都会被阻塞直到他们能够获得到锁。同一个线程可以多次 lock 同一个 monitor，每次 unlock都会释放一次对 monitor 的锁。&lt;/p&gt;

&lt;p&gt;Java 中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;关键字来自动获取和释放 monitor 的锁，在&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;修饰的方法或代码块开始运行时会自动尝试 lock 相应对象的 monitor，只有 lock 操作成功才会接着往下执行，当方法或代码块（不管是正常还是非正常）执行完后，会自动 unlock 相应的 monitor。&lt;/p&gt;

&lt;p&gt;这里 monitor 对应的对象是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是非静态方法，那么 monitor 对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;指向的对象。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是静态方法，那么 monitor 对象是该类的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是代码块，那么需要显示指定对象作为 monitor 对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monitor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;staticLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 1: 修饰非静态方法, monitor 对象是 this&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 2: 修饰非静态方法内部代码块, monitor 对象是 this, 等价于1&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innerAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 3: 修饰非静态方法内部代码块并显示指定了 lock 为 monitor 对象&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innerAddWithOtherMonitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 4: 修饰静态方法, monitor 对象是 Monitor.cass&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 5: 修饰静态方法内部方法块，monitor 对象是 Monitor.class, 等价于4&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticInnerAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Monitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 6: 修饰静态方法内部方法块并显式指定了 staticLock 为 monitor 对象&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticInnerAddWithOtherMonitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;staticLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;22-wait-sets-and-notification&quot;&gt;2.2 Wait Sets and Notification&lt;/h3&gt;

&lt;p&gt;Java 中每个对象除了都和一个 monitor 关联外, 还会和一个 wait set 相关联。wait set是一个线程集, 当一个对象新创建时，它的 wait set 是空的。添加线程到 wait set 和从 wait set 移除线程等基础操作都是原子的。wait set 状态受到以下几种方法影响：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;interruptions&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;221-wait&quot;&gt;2.2.1 Wait&lt;/h4&gt;

&lt;p&gt;等待动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wait(long millisecs)&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait(long millisecs, int nanosecs)&lt;/code&gt; 方法被调用时，一个处在等待状态的线程可正常退出或通过抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常退出。&lt;/p&gt;

&lt;p&gt;假设线程&lt;em&gt;t&lt;/em&gt; 将在对象&lt;em&gt;m&lt;/em&gt; 上执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;方法（&lt;em&gt;n&lt;/em&gt; 是&lt;em&gt;t&lt;/em&gt; 在&lt;em&gt;m&lt;/em&gt; 上已获取锁的次数），那么会有下面几种情况发生：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;em&gt;n&lt;/em&gt; 是0， 那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalMonitorStateException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果是定时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;millisecs&lt;/code&gt;参数是负的或者&lt;code class=&quot;highlighter-rouge&quot;&gt;nanosecs&lt;/code&gt;参数不在0-999999范围内，那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果线程&lt;em&gt;t&lt;/em&gt; 被interrupted，那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常，并且&lt;em&gt;t&lt;/em&gt; 的 interruption status会被设置为 false&lt;/li&gt;
  &lt;li&gt;除去上面的情况，会发生:
    &lt;ol&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 会被添加到&lt;em&gt;m&lt;/em&gt; 的 wait set 中，并释放对&lt;em&gt;m&lt;/em&gt; 的&lt;em&gt;n&lt;/em&gt; 次锁。&lt;/li&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 不会再执行任何操作直到它从&lt;em&gt;m&lt;/em&gt; 的 wait sets 里移除。线程会在以下动作发生时从 wait sets 中移除：
        &lt;ul&gt;
          &lt;li&gt;&lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;方法被调用，而&lt;em&gt;t&lt;/em&gt; 刚好作为被选中的线程。&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;方法被调用&lt;/li&gt;
          &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 的interrupt动作发生&lt;/li&gt;
          &lt;li&gt;带超时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;在超时时&lt;/li&gt;
          &lt;li&gt;虚假唤醒（spurious wake-ups），为了避免虚假唤醒，一般将判断条件放到循环中。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 再对 &lt;em&gt;m&lt;/em&gt; 进行 &lt;em&gt;n&lt;/em&gt; 次锁。&lt;/li&gt;
      &lt;li&gt;如果线程&lt;em&gt;t&lt;/em&gt; 是因为 interrupt 而从 wait set 中移除，那么线程&lt;em&gt;t&lt;/em&gt; 的interruption status会被设置为 false ，并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;222-notification&quot;&gt;2.2.2 Notification&lt;/h4&gt;

&lt;p&gt;通知动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt; 方法被调用时，继续上面线程的例子说明通知动作发生时的状况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 &lt;em&gt;n&lt;/em&gt; 是0，那么抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalMonitorStateException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果 &lt;em&gt;n&lt;/em&gt; 大于0并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;动作，那么如果 &lt;em&gt;m&lt;/em&gt; 的 wait set 不是空的，那么会从 wait set 随机移除一个线程 &lt;em&gt;u&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;若果 &lt;em&gt;n&lt;/em&gt; 大于0并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;动作，那么 &lt;em&gt;m&lt;/em&gt; 的 wait set 中的所有线程都会被移除，注意虽然 wait set 中所有的线程都会被唤醒，但是在任意时刻只有一个线程能够重新获得 monitor 的锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;223-interruptions&quot;&gt;2.2.3 Interruptions&lt;/h4&gt;

&lt;p&gt;中断动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupt()&lt;/code&gt; 方法被调用时，假设线程&lt;em&gt;t&lt;/em&gt; 会调用线程&lt;em&gt;u&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;u.interrupt()&lt;/code&gt;，其中的&lt;em&gt;t&lt;/em&gt; 和&lt;em&gt;u&lt;/em&gt; 可以是同一个线程，中断动作会将线程&lt;em&gt;u&lt;/em&gt; 的中断标志（interruption status）设置为true。其次如果线程在某个对象 &lt;em&gt;m&lt;/em&gt; 的 wait set 里，那么 &lt;em&gt;u&lt;/em&gt; 将从这个 wait set 里移除，这样会使 &lt;em&gt;u&lt;/em&gt; 从睡眠状态被唤醒，重新获得 &lt;em&gt;m&lt;/em&gt; 的 monitor 锁后抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.isInterrupted()&lt;/code&gt; 可以获取线程的中断状态，&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt; 可以获取线程的中断状态并重置中断状态为false。&lt;/p&gt;

&lt;h4 id=&quot;224-waits-notification-和-interruption-的交互&quot;&gt;2.2.4 Waits, Notification 和 Interruption 的交互&lt;/h4&gt;

&lt;p&gt;如果一个处于 waiting 状态的线程同时收到了通知动作和中断动作，那么它可能会发生：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;中正常返回，挂起interrupt动作（此时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt;会返回 true ）&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;中返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，通知动作也不会因为中断而丢失，假定一个线程集&lt;em&gt;s&lt;/em&gt; 在对象&lt;em&gt;m&lt;/em&gt; 的 wait set 里，另外一个线程调用了 &lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;方法，则可能会发生：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;s&lt;/em&gt; 中至少有一个线程正常返回；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;s&lt;/em&gt; 中的所有线程都返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意一个线程如果同时被&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;中断或唤醒，那么该线程会返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常，这时 wait set 里的另外一个线程需要被通知。&lt;/p&gt;

&lt;h3 id=&quot;sleep-and-yield&quot;&gt;Sleep and Yield&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt; 会使当前运行的线程睡眠（暂停执行）一段时间，但不会释放已拥有的 monitor 的锁。值得注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.yield()&lt;/code&gt;都没有保证同步机制，比如编译器可能不会将寄存器上已写的值保存到内存中去，也不会保证在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.yield()&lt;/code&gt;后重新载入值。&lt;/p&gt;

&lt;h3 id=&quot;线程状态&quot;&gt;线程状态&lt;/h3&gt;

&lt;p&gt;Java 给线程定义了6种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NEW: 新建，一个线程被创建但是还未调用其&lt;code class=&quot;highlighter-rouge&quot;&gt;start()&lt;/code&gt;方法时的状态&lt;/li&gt;
  &lt;li&gt;RUNNABLE: 可运行，一个线程在JVM中运行时的状态&lt;/li&gt;
  &lt;li&gt;BLOCKED: 阻塞，一个线程因为等待获取 monitor 的锁而被阻塞时的状态&lt;/li&gt;
  &lt;li&gt;WAITING: 等待，一个线程无限期的等待其他线程对其进行特定操作时的状态，比如调用没有带时间参数的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;方法&lt;/li&gt;
  &lt;li&gt;TIEMED_WAITING: 带超时的等待，一个线程在一定时间范围内等待其他线程对其进行特定操作时的状态，比如调用带时间参数的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sleep()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;方法&lt;/li&gt;
  &lt;li&gt;TERMINATED: 终止，一个线程退出后所处的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;waitNotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;waitNotifyWithTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RUNNABLE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lockThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;ThreadStatus:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BLOCKED&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WAITING&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;waitNotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIMED_WAITING&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;waitNotifyWithTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TERMINATED&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lockThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread1 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread2 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread3 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread4 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread5 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread6 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其输出为:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
thread1 state: NEW
thread2 state: RUNNABLE
thread3 state: BLOCKED
thread4 state: WAITING
thread5 state: TIMED_WAITING
thread6 state: TERMINATED
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;The Java Language Specifications Java SE 10 edition&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Java concurrency in practice&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Thinking in Java 4th edition&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
        <link>https://bitholic.org/2018/03/26/how-java-threads-works/</link>
        <guid isPermaLink="true">https://bitholic.org/2018/03/26/how-java-threads-works/</guid>
        
        <category>Concurrency</category>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
