<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bith01ic blog</title>
    <description>bitholic blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 30 Mar 2018 20:53:45 +0800</pubDate>
    <lastBuildDate>Fri, 30 Mar 2018 20:53:45 +0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>JVM GC Algorithms</title>
        <description>&lt;h2 id=&quot;关于gc&quot;&gt;关于GC&lt;/h2&gt;

&lt;p&gt;GC(Grabage Collection)是JVM中最核心的技术之一，随着多年的发展，GC算法出现了很多变种，适用于不同的环境，选择合适的算法对于新手来说往往是一个难点。虽然这些算法的实现有所不同，但其核心思想都可总结为两步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;找到所有“活”（使用）的对象&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;清除所有“死”（未使用）的对象。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;标记活的对象&quot;&gt;标记“活”的对象&lt;/h2&gt;

&lt;p&gt;所有的GC算法都要首先能找到“活”的对象，早期的GC使用引用计数的方式，这种方式有很多缺陷，比如不能清除循环引用。而现在的GC普遍采用可达性分析算法，首先来看一幅图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/GC_ROOTS.png&quot; alt=&quot;GC_ROOTS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出，我们可以从GC ROOTS开始找到所有有用的对象，那么首先看下什么样的对象可以作为有效的GC ROOTS：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;VM栈中引用的对象，或者说当前所有被调用方法的引用类型的参数、局部变量、临时值。&lt;/li&gt;
  &lt;li&gt;JNI(native栈)中引用的对象&lt;/li&gt;
  &lt;li&gt;方法区中常量或静态变量引用的对象&lt;/li&gt;
  &lt;li&gt;系统类（由bootstrap/system class loader加载的对象，比如 rt.jar 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.*&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;其它&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;标记时就可以从这些GC ROOTS出发找到当前所有有用的对象，并将其标记为“活”对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是，GC进程在执行标记时，应用进程是需要被停止的，对于应用层来说，这个阶段被称为“Stop the World(STW)”。并且暂停的时间取决于“活”对象的数目，而不在于堆的大小。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;清除无用的对象&quot;&gt;清除无用的对象&lt;/h2&gt;

&lt;p&gt;不同的GC算法主要的区别就在于如何清除无用对象，并且大致可以分为以下几种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Sweep（清除）：这是最简单的方式，它直接将标记为无用的对象释放。一般内部维持一个free-list，记录所有空闲的空间，这种方式的问题在于会产生很多的内存碎片，可能出现内存碎片加起来很大但确出现OOM的情况。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_Sweep.png&quot; alt=&quot;Mark_Sweep&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Compact（压缩/整理）：这种方式弥补了Sweep的缺点，在执行清除后，将所有活着的对象都复制到一块，避免了内存碎片的产生。这种方法的缺点是增加了STW的时间，因为拷贝对象和更改引用地址需要花费额外的时间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_Sweep_Compact.png&quot; alt=&quot;Mark_Sweep_Compact&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copy（复制）：这种方式和Compact很像，都是重新分配活对象的空间，但是Copy一般使用两个空间，称为存活区，每次GC时都将存活的对象放到其中一个存活区里，这种方式的好处是拷贝可以和标记同时进行，降低了STW的时间，缺点是需要两个存活区，并且他们都得足够大以存放活对象，这就浪费了一些内存空间。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/Mark_and_Copy.png&quot; alt=&quot;Mark_and_Copy&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Inremental（增量）：增量不是一种新的算法，它的基本思想是如果GC一次性进行所有的垃圾清理会造成很长的STW，那么就将GC过程分为多个阶段，每次只用前面提到的算法来收集部分区域。这种方式的缺陷是带来了线程切换的额外消耗，造成系统吞吐量下降。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Generational（分代）：分代也不是一种新的算法，它的基本思想是将内存分代，不同的代使用前面提到过的不同的算法。一般将内存分为新生代（Young Generation）、老年代（Old/Tenured Generation），永久代（Permanent Generation），新生代一般存储刚产生的、存活周期短的对象，在新生代存活超过一定周期后对象会被放入老年代，永久代一般存储类型或方法信息（方法区），永久代现在也叫元空间（Metaspace）。在年轻代一般选择效率较高的复制算法，老年代一般选择标记-压缩算法。比较典型的分代如下示，后面再进行详细分析。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/GC_generations.png&quot; alt=&quot;GC_generations&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在选择GC算法时经常要考虑三个非常重要的方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Throughput（吞吐量）：在单位时间内能够处理的任务量，比如一些统计应用要求在一定时间内处理的任务量越多越好，允许个别任务响应很慢。&lt;/li&gt;
  &lt;li&gt;Latency（响应速度）：任务的平均响应时间越短越好，比如一般的web应用要求最快的响应速度。&lt;/li&gt;
  &lt;li&gt;Capacity（容量）：容量主要针对在使用一些小内存的机器时占用更少的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jvm上使用的垃圾回收器&quot;&gt;JVM上使用的垃圾回收器&lt;/h2&gt;

&lt;h3 id=&quot;gc算法的分类&quot;&gt;GC算法的分类&lt;/h3&gt;
&lt;p&gt;从不同的角度分析分代GC，可以将其分为不同的类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按线程数分可以分为串行垃圾回收器（Serial）和并行垃圾回收器（Parallel）。串行垃圾回收器每次只使用一个线程进行垃圾回收，并行垃圾回收器每次将使用对个线程进行垃圾回收，在并行能力较强的CPU上，使用并行垃圾回收器可以减低STW时间。&lt;/li&gt;
  &lt;li&gt;按工作模式分可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序交替工作，尽可能的减少STW时间。而独占式则不管这一点，开始后就一直运行直到回收结束。&lt;/li&gt;
  &lt;li&gt;按工作的区域分又可以分为新生代垃圾回收器和老年代垃圾回收器。&lt;/li&gt;
  &lt;li&gt;按内存碎片处理方式又可分为压缩式垃圾回收器和非压缩式垃圾回收器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先来看下目前JVM（Java 8）中常用的GC算法（后面会详细分析每一种）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;新生代&lt;/th&gt;
      &lt;th&gt;老年代&lt;/th&gt;
      &lt;th&gt;JVM参数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Incremental&lt;/td&gt;
      &lt;td&gt;Incremental&lt;/td&gt;
      &lt;td&gt;-Xincgc&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Serial&lt;/td&gt;
      &lt;td&gt;Serial&lt;/td&gt;
      &lt;td&gt;-XX:+UseSerialGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parallel Scavenge&lt;/td&gt;
      &lt;td&gt;Serial&lt;/td&gt;
      &lt;td&gt;-XX:+UseParallelGC -XX:-UseParallelOldGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parallel Scavenge&lt;/td&gt;
      &lt;td&gt;Parallel Old&lt;/td&gt;
      &lt;td&gt;-XX:+UseParallelGC -XX:+UseParallelOldGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Serial&lt;/td&gt;
      &lt;td&gt;CMS&lt;/td&gt;
      &lt;td&gt;-XX:-UseParNewGC -XX:+UseConcMarkSweepGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Parallel New&lt;/td&gt;
      &lt;td&gt;CMS&lt;/td&gt;
      &lt;td&gt;-XX:+UseParNewGC -XX:+UseConcMarkSweepGC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;G1&lt;/td&gt;
      &lt;td&gt;G1&lt;/td&gt;
      &lt;td&gt;-XX:+UseG1GC&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;如何查看gc信息&quot;&gt;如何查看GC信息&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;可通过JDK自带的工具jvisualvm查看可视化的GC过程&lt;/li&gt;
  &lt;li&gt;可通过设置JVM启动参数&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps&lt;/code&gt;来打印GC信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;在翻阅文档的时候无意发现：JDK参数中-X开头的参数表示非标准的功能设置并且可能在后续JDK版本中被移除。-XX开头的参数表示非稳定的功能设置，行为可能在未提醒用户的情况下被改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;minor-gc-major-gc-与-full-gc&quot;&gt;Minor GC 、Major GC 与 Full GC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Minor GC: 一般将发生在新生代（包括Eden和Survivor区域）的内存回收称为 Minor GC。关于Minor GC需要注意的几点有：
    &lt;ol&gt;
      &lt;li&gt;当JVM无法为一个新的对象分配空间时会触发 Minor GC，比如当Eden区满了的时候。&lt;/li&gt;
      &lt;li&gt;在执行 Minor GC 操作时并不会影响到永久代，从永久代到年轻代的引用会被当做GC ROOTS，年轻代到永久代的引用在标记阶段会被直接忽略。&lt;/li&gt;
      &lt;li&gt;可能与感官相违背的是 Minor GC 带来的 STW 时间并不会特别久，因为新生代中大部分的对象都不符合GC存活条件，反而执行GC的过程会很快。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Major GC: 清理老年代&lt;/li&gt;
  &lt;li&gt;Full GC: 清理整个堆空间，包括新生代、老年代和元空间，通常发生在触发一次Minor GC时，发现统计数据说之前Minor GC的平均晋升大小比目前老年代的剩余的空间大，则不会触发Minor GC而改为触发Full GC。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;serial-gc&quot;&gt;Serial GC&lt;/h4&gt;

&lt;p&gt;串行垃圾回收器在新生代使用 mark-copy 算法，在老年代使用 mark-sweep-compact 算法。这种GC方式是单线程的，不能充分利用多核CPU的并行能力，并且在其执行时，会一直STW。这种方式的实现相对简单，没有线程切换的开销，在单CPU或较小内存的机器上性能表现可以超过并行回收器和并发回收器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/SerialGC.png&quot; alt=&quot;SerialGC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面分析几个Serial GC的日志：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2018-03-29T11:32:52.768-0800: 74.708: [GC (Allocation Failure) 2018-03-29T11:32:52.768-0800: 74.708: [DefNew: 35074K-&amp;gt;2K(39424K), 0.0008172 secs] 37049K-&amp;gt;1977K(126848K), 0.0008542 secs] [Times: user=0.06 sys=0.00, real=0.06 secs]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2018-03-29T11:32:52.768-0800&lt;/code&gt;: GC开始的时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;74.708&lt;/code&gt;: 相对于JVM启动时的GC开始时间，单位为秒&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;: 区分Minor GC和Full GC, 这里表示Minor GC&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Allocation Failure&lt;/code&gt;: 发生GC的原因，这里表示触发GC的原因是新生代分配新的内存空间失败。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DefNew&lt;/code&gt;: 使用的垃圾回收器名称，这个奇怪的名字表示单线程的mark-copy STW收集器。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;35074K-&amp;gt;2K&lt;/code&gt;: 垃圾回收前后新生代的大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(39424K)&lt;/code&gt;: 新生代的总大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;37049K-&amp;gt;1977K&lt;/code&gt;: 垃圾回收前后堆的大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(126848K)&lt;/code&gt;: 堆的总大小&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0008542 secs&lt;/code&gt;: GC执行的时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Times: user=0.00 sys=0.00, real=0.00 secs]&lt;/code&gt;: 不同GC事件占据的时间，user表示垃圾回收线程消耗的CPU时间，sys表示花费在系统调用或等待系统事件的时间，real表示STW的时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;parallel-gc&quot;&gt;Parallel GC&lt;/h4&gt;

&lt;p&gt;并行垃圾回收器在新生代使用 mark-copy 算法，在老年代使用 mark-sweep-compact 算法，但是这种方式会使用多个线程来执行垃圾回收动作，因此称为“Parallel”，这种方式的回收时间相对较少，可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:ParallelGCThreads=N&lt;/code&gt;调整Parallel GC的线程数，默认值是机器CPU的核数。这种方式可以最大化吞吐量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/ParallelGC.png&quot; alt=&quot;ParallelGC&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cms-concurrent-mark-and-sweep&quot;&gt;CMS (Concurrent Mark and Sweep)&lt;/h4&gt;

&lt;p&gt;CMS垃圾回收器在年轻代使用parallel mark-copy 算法，在老年代使用 concurrent mark-sweep 算法。这种算法主要解决的问题是减少清理老年代的暂停时间，他并不会整理老年代的内存空间，使用free-list来管理空闲内存，在mark-sweep阶段的大部分操作都与应用程序并发运行。这种方式可以做大话降低延迟。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/JVM_GC_Algorithms/CMS.png&quot; alt=&quot;CMS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CMS在对老年代执行垃圾回收时分为以下几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;起始标记：这个阶段会STW，这个阶段的目的是标记所有由GC ROOTS或年轻代指向的第一个引用。&lt;/li&gt;
  &lt;li&gt;并发标记：&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/29/JVM_GC_Algorithms/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/29/JVM_GC_Algorithms/</guid>
        
        <category>Java</category>
        
        <category>JVM</category>
        
        
      </item>
    
      <item>
        <title>How Java Threads Works</title>
        <description>&lt;h1 id=&quot;how-java-threads-works&quot;&gt;How Java Threads Works&lt;/h1&gt;

&lt;h2 id=&quot;1-线程简介&quot;&gt;1. 线程简介&lt;/h2&gt;

&lt;h3 id=&quot;11-并发concurrency的历史&quot;&gt;1.1 并发（Concurrency）的历史：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在上古时期，那时的计算机还没有操作系统，程序只能从头到尾的运行并且能够获取计算机的所有资源。&lt;/li&gt;
  &lt;li&gt;在操作系统出现以后，允许了多个程序作为不同的&lt;strong&gt;进程（processes）&lt;/strong&gt;同时运行，操作系统给进程分配资源，线程间可以通过sockets, signal, shared memory, files等进行通信。&lt;/li&gt;
  &lt;li&gt;随着计算机程序复杂度的提高，同一个进程也需要在同时运行不同的任务，这就激发了线程（threads）的出现。线程允许在同一个进程内并发执行多个程序流，并且它们共享进程的资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程也被称为轻量级进程，在现代操作系统上，线程（而不是进程）往往作为CPU调度的基本单元。在现代的多核CPU上，线程能够做到真正意义上的同时运行（并行）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;并发（Concurencey）：多个任务以时间片的方式在一段时间内交替运行（上下文切换），在指定时刻，还是只有一个任务在执行。&lt;/p&gt;

  &lt;p&gt;并行（Parallelism）：多个任务真正的同时运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-线程带来的风险&quot;&gt;1.2 线程带来的风险&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;安全问题：&lt;/li&gt;
  &lt;li&gt;活性问题：&lt;/li&gt;
  &lt;li&gt;性能问题：&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-java中的线程&quot;&gt;2. Java中的线程&lt;/h2&gt;

&lt;p&gt;Java中线程是以类&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;来表示的，在Java中创建线程的唯一方式就是创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;的实例。可通过调用线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;start()&lt;/code&gt;方法来启动这个线程。&lt;/p&gt;

&lt;p&gt;没有正确同步的线程的行为往往会让人感到困扰。Java通过&lt;em&gt;Java programming language memory model&lt;/em&gt;(有时会简称为the memory model)的语义描述多线程的行为，这个语义并没有规定多线程程序应该怎样运行，而是描述了多线程程序运行时可被允许的行为表现。&lt;/p&gt;

&lt;h3 id=&quot;21-同步synchronization&quot;&gt;2.1 同步（Synchronization）&lt;/h3&gt;

&lt;p&gt;Java 语言提供了多种线程间通信的机制，最常见也最基础的就是通过 monitors 实现的同步机制。Java 中的每个对象都会与一个 monitor 相关联，线程可以 &lt;em&gt;lock&lt;/em&gt; 和 &lt;em&gt;unlock&lt;/em&gt; 这个 monitor。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程 lock 了一个对象的 monitor 有时也称为线程拥有了 monitor 的锁或线程拥有了对象的锁，同样，线程 unlock 一个对象的 monitor 也称为线程释放了 monitor 的锁或线程释放了对象的锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在同一个时刻只能有一个线程能够拥有对 monitor 的锁，其它尝试 lock 这个 monitor 的线程都会被阻塞直到他们能够获得到锁。同一个线程可以多次 lock 同一个 monitor，每次 unlock都会释放一次对 monitor 的锁。&lt;/p&gt;

&lt;p&gt;Java 中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;关键字来自动获取和释放 monitor 的锁，在&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;修饰的方法或代码块开始运行时会自动尝试 lock 相应对象的 monitor，只有 lock 操作成功才会接着往下执行，当方法或代码块（不管是正常还是非正常）执行完后，会自动 unlock 相应的 monitor。&lt;/p&gt;

&lt;p&gt;这里 monitor 对应的对象是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是非静态方法，那么 monitor 对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;指向的对象。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是静态方法，那么 monitor 对象是该类的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象。&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronzied&lt;/code&gt;修饰的是代码块，那么需要显示指定对象作为 monitor 对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monitor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;staticLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 1: 修饰非静态方法, monitor 对象是 this&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 2: 修饰非静态方法内部代码块, monitor 对象是 this, 等价于1&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innerAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 3: 修饰非静态方法内部代码块并显示指定了 lock 为 monitor 对象&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;innerAddWithOtherMonitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 4: 修饰静态方法, monitor 对象是 Monitor.cass&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 5: 修饰静态方法内部方法块，monitor 对象是 Monitor.class, 等价于4&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticInnerAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Monitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 6: 修饰静态方法内部方法块并显式指定了 staticLock 为 monitor 对象&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticInnerAddWithOtherMonitor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;staticLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;22-wait-sets-and-notification&quot;&gt;2.2 Wait Sets and Notification&lt;/h3&gt;

&lt;p&gt;Java 中每个对象除了都和一个 monitor 关联外, 还会和一个 wait set 相关联。wait set是一个线程集, 当一个对象新创建时，它的 wait set 是空的。添加线程到 wait set 和从 wait set 移除线程等基础操作都是原子的。wait set 状态受到以下几种方法影响：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;interruptions&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;221-wait&quot;&gt;2.2.1 Wait&lt;/h4&gt;

&lt;p&gt;等待动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;wait(long millisecs)&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;wait(long millisecs, int nanosecs)&lt;/code&gt; 方法被调用时，一个处在等待状态的线程可正常退出或通过抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常退出。&lt;/p&gt;

&lt;p&gt;假设线程&lt;em&gt;t&lt;/em&gt; 将在对象&lt;em&gt;m&lt;/em&gt; 上执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;方法（&lt;em&gt;n&lt;/em&gt; 是&lt;em&gt;t&lt;/em&gt; 在&lt;em&gt;m&lt;/em&gt; 上已获取锁的次数），那么会有下面几种情况发生：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;em&gt;n&lt;/em&gt; 是0， 那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalMonitorStateException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果是定时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;millisecs&lt;/code&gt;参数是负的或者&lt;code class=&quot;highlighter-rouge&quot;&gt;nanosecs&lt;/code&gt;参数不在0-999999范围内，那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalArgumentException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果线程&lt;em&gt;t&lt;/em&gt; 被interrupted，那么会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常，并且&lt;em&gt;t&lt;/em&gt; 的 interruption status会被设置为 false&lt;/li&gt;
  &lt;li&gt;除去上面的情况，会发生:
    &lt;ol&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 会被添加到&lt;em&gt;m&lt;/em&gt; 的 wait set 中，并释放对&lt;em&gt;m&lt;/em&gt; 的&lt;em&gt;n&lt;/em&gt; 次锁。&lt;/li&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 不会再执行任何操作直到它从&lt;em&gt;m&lt;/em&gt; 的 wait sets 里移除。线程会在以下动作发生时从 wait sets 中移除：
        &lt;ul&gt;
          &lt;li&gt;&lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;方法被调用，而&lt;em&gt;t&lt;/em&gt; 刚好作为被选中的线程。&lt;/li&gt;
          &lt;li&gt;&lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;方法被调用&lt;/li&gt;
          &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 的interrupt动作发生&lt;/li&gt;
          &lt;li&gt;带超时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;在超时时&lt;/li&gt;
          &lt;li&gt;虚假唤醒（spurious wake-ups），为了避免虚假唤醒，一般将判断条件放到循环中。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;线程&lt;em&gt;t&lt;/em&gt; 再对 &lt;em&gt;m&lt;/em&gt; 进行 &lt;em&gt;n&lt;/em&gt; 次锁。&lt;/li&gt;
      &lt;li&gt;如果线程&lt;em&gt;t&lt;/em&gt; 是因为 interrupt 而从 wait set 中移除，那么线程&lt;em&gt;t&lt;/em&gt; 的interruption status会被设置为 false ，并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;222-notification&quot;&gt;2.2.2 Notification&lt;/h4&gt;

&lt;p&gt;通知动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt; 方法被调用时，继续上面线程的例子说明通知动作发生时的状况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 &lt;em&gt;n&lt;/em&gt; 是0，那么抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalMonitorStateException&lt;/code&gt;异常&lt;/li&gt;
  &lt;li&gt;如果 &lt;em&gt;n&lt;/em&gt; 大于0并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;动作，那么如果 &lt;em&gt;m&lt;/em&gt; 的 wait set 不是空的，那么会从 wait set 随机移除一个线程 &lt;em&gt;u&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;若果 &lt;em&gt;n&lt;/em&gt; 大于0并且是&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyAll()&lt;/code&gt;动作，那么 &lt;em&gt;m&lt;/em&gt; 的 wait set 中的所有线程都会被移除，注意虽然 wait set 中所有的线程都会被唤醒，但是在任意时刻只有一个线程能够重新获得 monitor 的锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;223-interruptions&quot;&gt;2.2.3 Interruptions&lt;/h4&gt;

&lt;p&gt;中断动作发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupt()&lt;/code&gt; 方法被调用时，假设线程&lt;em&gt;t&lt;/em&gt; 会调用线程&lt;em&gt;u&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;u.interrupt()&lt;/code&gt;，其中的&lt;em&gt;t&lt;/em&gt; 和&lt;em&gt;u&lt;/em&gt; 可以是同一个线程，中断动作会将线程&lt;em&gt;u&lt;/em&gt; 的中断标志（interruption status）设置为true。其次如果线程在某个对象 &lt;em&gt;m&lt;/em&gt; 的 wait set 里，那么 &lt;em&gt;u&lt;/em&gt; 将从这个 wait set 里移除，这样会使 &lt;em&gt;u&lt;/em&gt; 从睡眠状态被唤醒，重新获得 &lt;em&gt;m&lt;/em&gt; 的 monitor 锁后抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.isInterrupted()&lt;/code&gt; 可以获取线程的中断状态，&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt; 可以获取线程的中断状态并重置中断状态为false。&lt;/p&gt;

&lt;h4 id=&quot;224-waits-notification-和-interruption-的交互&quot;&gt;2.2.4 Waits, Notification 和 Interruption 的交互&lt;/h4&gt;

&lt;p&gt;如果一个处于 waiting 状态的线程同时收到了通知动作和中断动作，那么它可能会发生：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;中正常返回，挂起interrupt动作（此时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt;会返回 true ）&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;中返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，通知动作也不会因为中断而丢失，假定一个线程集&lt;em&gt;s&lt;/em&gt; 在对象&lt;em&gt;m&lt;/em&gt; 的 wait set 里，另外一个线程调用了 &lt;em&gt;m&lt;/em&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;方法，则可能会发生：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;s&lt;/em&gt; 中至少有一个线程正常返回；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;s&lt;/em&gt; 中的所有线程都返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意一个线程如果同时被&lt;code class=&quot;highlighter-rouge&quot;&gt;notify()&lt;/code&gt;中断或唤醒，那么该线程会返回并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;异常，这时 wait set 里的另外一个线程需要被通知。&lt;/p&gt;

&lt;h3 id=&quot;sleep-and-yield&quot;&gt;Sleep and Yield&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt; 会使当前运行的线程睡眠（暂停执行）一段时间，但不会释放已拥有的 monitor 的锁。值得注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.yield()&lt;/code&gt;都没有保证同步机制，比如编译器可能不会将寄存器上已写的值保存到内存中去，也不会保证在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.yield()&lt;/code&gt;后重新载入值。&lt;/p&gt;

&lt;h3 id=&quot;线程状态&quot;&gt;线程状态&lt;/h3&gt;

&lt;p&gt;Java 给线程定义了6种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NEW: 新建，一个线程被创建但是还未调用其&lt;code class=&quot;highlighter-rouge&quot;&gt;start()&lt;/code&gt;方法时的状态&lt;/li&gt;
  &lt;li&gt;RUNNABLE: 可运行，一个线程在JVM中运行时的状态&lt;/li&gt;
  &lt;li&gt;BLOCKED: 阻塞，一个线程因为等待获取 monitor 的锁而被阻塞时的状态&lt;/li&gt;
  &lt;li&gt;WAITING: 等待，一个线程无限期的等待其他线程对其进行特定操作时的状态，比如调用没有带时间参数的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;方法&lt;/li&gt;
  &lt;li&gt;TIEMED_WAITING: 带超时的等待，一个线程在一定时间范围内等待其他线程对其进行特定操作时的状态，比如调用带时间参数的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;sleep()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;join()&lt;/code&gt;方法&lt;/li&gt;
  &lt;li&gt;TERMINATED: 终止，一个线程退出后所处的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;waitNotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;waitNotifyWithTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;interrupted&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NEW&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RUNNABLE&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lockThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;ThreadStatus:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BLOCKED&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ThreadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;WAITING&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;waitNotify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIMED_WAITING&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;waitNotifyWithTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TERMINATED&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lockThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread1 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread2 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread3 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread4 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread5 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;thread6 state: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其输出为:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
thread1 state: NEW
thread2 state: RUNNABLE
thread3 state: BLOCKED
thread4 state: WAITING
thread5 state: TIMED_WAITING
thread6 state: TERMINATED
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;The Java Language Specifications Java SE 10 edition&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Java concurrency in practice&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Thinking in Java 4th edition&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/26/how-java-threads-works/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/26/how-java-threads-works/</guid>
        
        <category>Concurrency</category>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
